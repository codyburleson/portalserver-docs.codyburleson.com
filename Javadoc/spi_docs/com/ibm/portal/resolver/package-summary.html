<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0) on Sat Dec 12 10:33:41 EST 2020 -->
<TITLE>
com.ibm.portal.resolver (IBM WebSphere Portal Version 8.5.0.0 SPI Docs)
</TITLE>

<META NAME="date" CONTENT="2020-12-12">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="com.ibm.portal.resolver (IBM WebSphere Portal Version 8.5.0.0 SPI Docs)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/ibm/portal/propertybroker/service/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/ibm/portal/resolver/accessors/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/ibm/portal/resolver/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package com.ibm.portal.resolver
</H2>
Contains the main interfaces that extenders of the URI resolution infrastructure 
must implement.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/AcceptContext.html" title="interface in com.ibm.portal.resolver">AcceptContext</A></B></TD>
<TD>Context that provides access to accepted content types</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/ActionContext.html" title="interface in com.ibm.portal.resolver">ActionContext</A></B></TD>
<TD>Extension of the COR <A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver"><CODE>PortletContext</CODE></A> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/AttributeContext.html" title="interface in com.ibm.portal.resolver">AttributeContext</A></B></TD>
<TD>Provides access to attributes information</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/Binding.html" title="interface in com.ibm.portal.resolver">Binding</A></B></TD>
<TD>Tagging interface for bindings during the resolution process</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/Constants.html" title="interface in com.ibm.portal.resolver">Constants</A></B></TD>
<TD>Multi purpose constants that support the POC framework</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/CookieContext.html" title="interface in com.ibm.portal.resolver">CookieContext</A></B></TD>
<TD>Context that provides access to cookies across different types of requests
 such a servlet or portlet requests.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/DigestContext.html" title="interface in com.ibm.portal.resolver">DigestContext</A></B></TD>
<TD>Denotes a <CODE>Context</CODE> that provides access to a digest.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/EventContext.html" title="interface in com.ibm.portal.resolver">EventContext</A></B></TD>
<TD>Extension of the COR <A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver"><CODE>PortletContext</CODE></A> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/FormDataContext.html" title="interface in com.ibm.portal.resolver">FormDataContext</A></B></TD>
<TD>Extension of the COR <CODE>Context</CODE> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/HeaderContext.html" title="interface in com.ibm.portal.resolver">HeaderContext</A></B></TD>
<TD>Provides access to header information</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/Lookup.html" title="interface in com.ibm.portal.resolver">Lookup</A></B></TD>
<TD>
 Constructs an XML source document that represents an individual ATOM entry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/LookupService.html" title="interface in com.ibm.portal.resolver">LookupService</A></B></TD>
<TD>
 Service that allows to map between the URI to a resource and an ATOM feed
 that describes this resource, including its entry URL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/MimeContext.html" title="interface in com.ibm.portal.resolver">MimeContext</A></B></TD>
<TD>Extension of the COR <A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver"><CODE>PortletContext</CODE></A> for use in a JSR268 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/PocURL.html" title="interface in com.ibm.portal.resolver">PocURL</A></B></TD>
<TD>The <A HREF="../../../../com/ibm/portal/resolver/PocURL.html" title="interface in com.ibm.portal.resolver"><CODE>PocURL</CODE></A> is a URL that addresses a piece of content (POC).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver">PortletContext</A></B></TD>
<TD>Extension of the COR <CODE>Context</CODE> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/RenderContext.html" title="interface in com.ibm.portal.resolver">RenderContext</A></B></TD>
<TD>Extension of the COR <A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver"><CODE>PortletContext</CODE></A> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/ResolutionService.html" title="interface in com.ibm.portal.resolver">ResolutionService</A></B></TD>
<TD>
 Service that allows to resolve a URI to navigational state in the context of
 WebSphere Portal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/Resolved.html" title="interface in com.ibm.portal.resolver">Resolved</A></B></TD>
<TD>Identification of the result of the resolution process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/ResourceContext.html" title="interface in com.ibm.portal.resolver">ResourceContext</A></B></TD>
<TD>Extension of the COR <A HREF="../../../../com/ibm/portal/resolver/PortletContext.html" title="interface in com.ibm.portal.resolver"><CODE>PortletContext</CODE></A> for use in a JSR168 portlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../com/ibm/portal/resolver/ServletContext.html" title="interface in com.ibm.portal.resolver">ServletContext</A></B></TD>
<TD>Extension of the COR context for use in a servlet.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package com.ibm.portal.resolver Description
</H2>

<P>
Contains the main interfaces that extenders of the URI resolution infrastructure 
must implement.

<h2>Package Specification</h2> The URI addressability framework consists of thow 
following functional groups
<ol>
        <li>
                <a href="#resolution">Resolution</a> of URIs to views in WebSphere Portal
        <li>
                <a href="#lookup">Mapping</a> of URIs to URLs to services for such URIs
        <li>
                <a href="#tags">Tag</a> API that can be used from both portlets and servlets
</ol>

<a name="resolution"></a><h3>Resolution of WebSphere Portal views</h3>
<a name="How_to_extend_the_resolver_infrastructure.3F"></a><h1>How to extend the 
resolver infrastructure?</h1>
<p>
Content providers need to provider a resolver implementation that resolves URIs 
and locates the target page and the target portlet window ID that contains a 
viewer. In addition there needs to be a viewer portlet implementation. Both 
pieces are decoupled and can reside in different bundles.
</p>
<a name="Implementing_the_viewer"></a><h2>Implementing the viewer</h2>
<p>
The viewer needs to be a portlet packaged in a WAR file. The implementation of 
the portlet is arbitrary. In addition to fulfilling the portlet specification 
the <code >portlet.xml</code > needs to specific a special <code >init-param</code > 
to link from the portlet to its resolver.

</p>
<pre>
&lt;init-param&gt;
  &lt;name&gt;com.ibm.portal.resolver.ResolutionService&lt;/name&gt;
  &lt;value&gt;%YOUR_UNIQUE_SERVICE_ID%&lt;/value&gt;
&lt;/init-param&gt;
</pre>

<p>
The parameter name <code >com.ibm.portal.resolver.ResolutionService</code > is 
predefined by the resolver infrastructure, the value references a valid location 
service handler for a COR service that extends the <code >com.ibm.portal.resolver.portlet</code > 
location type (defined again by the resolver infrastructure).
</p>
<p>
The actual service handler implementation may be implemented by any bundle, 
however it is advised to include the handler in the same WAR file that also 
contains the portlet. So the WAR file needs to contain a valid <code >plugin.xml</code > 
in the <code >META-INF</code > directory of the WAR file. This plugin has as a 
minimum to define the extension.
</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;plugin provider-name=&quot;%YOUR_PROVIDER_NAME%&quot; version=&quot;1.0.0&quot; 
name=&quot;%YOUR_PLUGIN_NAME%&quot; id=&quot;%YOUR_PLUGIN_ID%&quot;&gt;
  &lt;extension point=&quot;com.ibm.content.operations.registry. 
  locationServiceHandler&quot;&gt;
    &lt;serviceHandler class=&quot;%YOUR_HANDLER_IMPLEMENTATION_CLASS%&quot; 
        locationTypeId=&quot;com.ibm.portal.resolver.portlet&quot; id=&quot;% 
        YOUR_UNIQUE_SERVICE_ID%&quot;/&gt;

  &lt;/extension&gt;
&lt;/plugin&gt;
</pre>
<a name="Implementing_the_resolver"></a><h3>Implementing the resolver</h3>
<p>
The implementation class of the viewer resolver needs to implement the <code >com.ibm.portal.resolver.ResolutionService</code > 
interface. The 
purpose of the implementation is to initialize the state with portlet specific 
information that the portlet requires to get initialized. The URI that is passed 
to the resolver is of the format <code >portlet:&lt;portletWindowID&gt;:&lt;pageID&gt;:&lt;pocURI&gt;</code >, 
so the portlet can use the <code >portletWindowID</code > in conjunction with 
the <code >pocURI</code > and the state handling API in WebSphere Portal to modify the state.

</p>
<p>
In the simplest case the portlet is implemented as a JSR168 portlet and accepts 
the <code >pocURI</code > as a JSR168 render parameter. For this case the 
resolver can be implemented as follows:
</p>
<pre>

        /*
         * (non-Javadoc)
         *
         * @see com.ibm.portal.resolver.ResolutionService#resolve(com.ibm.portal.resolver. 
         Resolved,
         *      java.net.URI, java.util.Set, java.util.Map,
         *      com.ibm.portal.resolver.ResolutionContext)
         */
        public void resolve(final Resolved res, final URI uri,
                        final Set acceptedBindings, final Map params, final Context ctx)
                        throws ResolutionException, StateException {
                // lookup the required services first
                final Identification idSvc = services.getIdentification(ctx);
                final StateManagerService stateSvc = services.getStateManager(ctx);

                // decode the URI
                final PortletURI portletURI = new PortletURI(uri, idSvc);
                final ObjectID portletWindowID = portletURI.getPortletWindowID();
                final URI pocURI = portletURI.getPocURI();

                /*
                 * This is the critical piece of code that knows how to pass parameters
                 * to the target portlet. There is a tight coupling between this code
                 * and the code in the portlet that reads the parameters. That's why the
                 * ViewerResolver and the portlet code should reside in the same bundle
                 * (WAR file) and the extra indirection is required.
                 *
                 * This implementation makes use of a JSR168 render parameter to
                 * communicate state between the resolver and the portlet. As both the
                 * portlet code and the resolver have access to the same java classes,
                 * they can use a java constant for the parameter name. This in turn
                 * makes long parameter names unnecessary (the parameter is already
                 * scoped to the portlet instance by the state handling API). Short
                 * parameter names in turn help to reduce the URL lengths.
                 */
                final PortletAccessorFactory portletFct = (PortletAccessorFactory) stateSvc
                                .getAccessorFactory(PortletAccessorFactory.class);
                final PortletAccessorController portletCtrl = portletFct
                                .getPortletAccessorController(portletWndId, stateCtrl);
                try {
                        // current set of render parameters that can be modified
                        final Map renderParams = portletCtrl.getParameters();
                        /*
                         * It's critical to remember that the values for the render
                         * parameter map are of type String[] per JSR168 spec (not just
                         * plain strings!).
                         */
                        renderParams.put(PARAM_URI, new String[] { pocURI.toString() });
                } finally {
                        // done
                        portletCtrl.dispose();
                }
        }
</pre>
<p>
The constants <code >PARAM_URI</code > that appears in the code represents 
shared, internal knowledge between this resolver and the portlet implementation. 
As both are implemented in the same bundle however, this dependency is not 
fragile.
</p>
<a name="Implementing_the_portlet"></a><h3>Implementing the portlet</h3>

<p>
The portlet needs to be aware of the way it receives its initialization 
parameters. In the simplest case the portlet is a JSR168 portlet and uses a 
JSR168 render parameter to receive the <code >pocURI</code >. In this case the 
portlet can just read the parameter via the standard JSR168 APIs and only needs 
to share the parameter name with the resolver (ideally via a java constant that 
represents a very short parameter name).
</p>
<pre>
&lt;%@ page import=&quot;com.ibm.wps.resolver.viewer.ViewerConstants&quot; 
language=&quot;java&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;div class=&quot;portlet-section-body&quot;&gt;

&lt;p&gt;The portlet displays the render parameter &lt;b&gt;PARAM_URI&lt;/b&gt; 
that has been initialized
by the &lt;b&gt;ViewerResolver&lt;/b&gt;. &lt;/p&gt;

&lt;p&gt;

URI = &lt;%= request.getParameter(ViewerConstants.PARAM_URI) %&gt;
&lt;/p&gt;
&lt;/div&gt;
</pre>
<p>
The portlet does not need to implement any action semantics in this example, 
because the render parameter is just <a href="/wiki/index.php/Wp.engine.sdd.introduction.requirements#Navigational_State" title="Wp.engine.sdd.introduction.requirements">navigational 
state</a> that can be transfered in render requests. A real portlet with more 
logic would now generate markup containing (render-)links that modify or enhance 
these render parameters.
</p>
<a name="Implementing_the_custom_business_component_lookup"></a><h2>Implementing 
the custom business component lookup</h2>

<p>
In general providers need to implement the <code >com.ibm.portal.resolver.ResolutionService</code > 
interface by defining a service handler in the <code >Content Operations Registry</code > infrastructure 
with the ID <code >com.ibm.portal.resolver.ResolutionService</code >. This 
service handler needs to be associated (via the <code >locationTypeId</code > 
with a content location factory that in turn is associated with a URI scheme.
</p>
<p>
The responsibility for the resolver implementation is to modify the <a href="/wiki/index.php/Wp.engine.sdd.introduction.requirements#Navigational_State" title="Wp.engine.sdd.introduction.requirements">navigational 
state</a> such that it points to a page with a portlet that contains properly 
initialized initialization parameters.
</p>

<a name="Implementing_a_resolver_from_scratch"></a><h3>Implementing a resolver 
from scratch</h3>
<a name="Using_the_CAI_infrastructure"></a><h3>Using the CAI infrastructure</h3>
<p>
The CAI infrastructure greatly supports content providers in correctly 
implementing a resolver by maintaining mappings from business components to page/portlets. 
The CAI infrastructure provides a resolver that is associated width the <code >cai</code > 
URI scheme and that handles already many details of the state manipulation. CAI 
URIs have the format <code >cai:&lt;pocURI&gt;</code >. The CAI resolver has no 
dependency on the actual provider of the <code >pocURI</code > other than it 
needs to do a callback to pocURI specific resolution service to locate the page 
and portletWindowID based on the POC ID. The CAI resolver will then use these 
IDs to do the appropriate state manipulations automatically.

</p>
<p>
In order to do the page resolution CAI looks via the <code >COR</code > 
infrastructure for a service handler for the <code >pocURI</code > with the 
service id <code >com.ibm.portal.resolver.cai.BusinessComponentService</code >. 
The resulting service needs to implement the <code >com.ibm.portal.resolver.cai.BusinessComponentService</code > 
interface.
</p>
<p>
For most CAI based providers it will be simpler to determine the hosting 
business component ID than to find the target page and target portlet. So 
providers can implement he <code >BusinessComponentService</code > interface by 
first doing a lookup for the hosting business component ID and then dispatching 
to CAI's implementation of the <code >BusinessComponentService</code > interface 
that finds page and portlet based on the business component ID.

</p>
<p>
In this prototype code the business component lookup does not use any CAI APIs, 
yet. Instead it uses the <code >pocURI</code > scheme and just searches all 
deployed pages and all portlet windows until it finds a portlet window that has 
a title that matches the <code >pocURI</code > scheme. For the example 
implementation this means that in order to find the correct viewer portlet for 
the URI <code >SampleProvider:test</code > there needs to be a portlet installed 
on a page with a portlet title of <code >SampleProvider</code >.
</p>
<p>
This is how a simple business component lookup can be implemented
</p>
<pre>
        public DomainObjectRef resolve(final URI uri, final Map params, final Context 
        ctx) throws ResolutionException {
                LOGGER.info(&quot;finding the page: uri = &quot; + uri);
                try {
                        /*
                         * just chose a dummy type/id for the business component in this demo.
                         *
                         * This is the line of code that real components needs to override. These
                         * components need to do a lookup based on the uri to the type and the
                         * URI of a business component. Then they can use the same
                         * mechanism to dispatch to the business component lookup
                         *
                         */
                        final URI bcURI = BusinessComponentURI.newInstance(&quot;dummyType&quot;, &quot; 
                        dummyID&quot;, uri);
                        LOGGER.info(&quot;dispatching: bcURI = &quot; + bcURI);
                        // dispatch to the resolver for the BC URI
                        final ContentIntrospector ci = ctx.getContentIntrospector();
                        final ServiceHandler handler = ci.getServiceHandler(bcURI, 
                        BusinessComponentService.class.getName(), null, ctx);
                        LOGGER.info(&quot;handler = &quot; + handler);
                        if (handler&nbsp;!= null) {
                                // get the actual operation
                                final BusinessComponentService bizSvc = (BusinessComponentService) handler. 
                                getService(bcURI, ctx);
                                LOGGER.info(&quot;bizSvc = &quot; + bizSvc);
                                // dispatch
                                return bizSvc.resolve(bcURI, params, ctx);
                        } else {
                                // TODO throw the correct exception
                                throw new ServiceNotFoundException(&quot;service not found&quot;);
                        }
                } catch (ResolutionException ex) {
                        throw ex;
                } catch (Exception ex) {
                        // TODO throw the correct exception
                        throw new ResolutionProxyException(null, ex);
                }
        }

</pre>
<p>
In addition there needs to be a <code >plugin.xml</code > that is bundled with 
the lookup class that registers the business component lookup with the 
appropriate URI scheme (see the COR documentation for details).
</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;plugin provider-name=&quot;%YOUR_PROVIDER_NAME%&quot; version=&quot;1.0.0&quot; 
name=&quot;%YOUR_PLUGIN_NAME%&quot; id=&quot;%YOUR_PLUGIN_ID%&quot;&gt;

  &lt;extension point=&quot;com.ibm.content.operations.registry. 
  locationTypeContribution&quot;&gt;
    &lt;contentLocationType title=&quot;%YOUR_TITLE%&quot;
        match.uri.scheme=&quot;%YOUR_URI_SCHEME%&quot;
        class=&quot;%YOUR_CONTENT_LOCATION_FACTORY%&quot;
        id=&quot;%YOUR_LOCATION_TYPE_ID%&quot;/&gt;

  &lt;/extension&gt;
  &lt;extension point=&quot;com.ibm.content.operations.registry. 
  locationServiceHandler&quot;&gt;
    &lt;serviceHandler
        class=&quot;%YOUR_HANDLER_IMPLEMENTATION_CLASS%&quot;
        locationTypeId=&quot;%YOUR_LOCATION_TYPE_ID%&quot;
        id=&quot;com.ibm.portal.resolver.cai.BusinessComponentService&quot;/&gt;

  &lt;/extension&gt;
&lt;/plugin&gt;
</pre>
<a name="How_to_write_a_browser_portlet.3F"></a><h1>How to write a browser 
portlet?</h1>
<p>
Writing a browser portlet is fortunately very simple. The portlet needs to be a 
standard conformant portlet that can use a resolver specific tag library to 
easily generate its URLs.
</p>
<p>
In this prototype the portlet needs to ship the tag library on its own, but it 
can reference the tag implementation in the basic resolver infrastructure.
</p>
<pre>
        &lt;tag&gt;

        &lt;name&gt;url&lt;/name&gt;
        &lt;tag-class&gt;com.ibm.wps.resolver.tags.ResolvedUrlTag&lt;/tag-class&gt;
        &lt;body-content&gt;JSP&lt;/body-content&gt;
            &lt;attribute&gt;

            &lt;name&gt;uri&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
            &lt;type&gt;java.lang.String&lt;/type&gt;

        &lt;/attribute&gt;
    &lt;/tag&gt;
</pre>
<p>
Currently the tag only supports the generation of late binding URLs.
</p>
<p>
The portlet would then just use this tag to create links to the <code >pocURI</code >s.
</p>
<pre>
&lt;%@ taglib uri=&quot;http://www.ibm.com/xmlns/prod/websphere/portal/v60/ 
resolver/browser&quot; prefix=&quot;res&quot; %&gt;

&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;div class=&quot;portlet-section-body&quot;&gt;
&lt;p&gt;
Demo of late binding to the following URLs
&lt;/p&gt;
&lt;ul&gt;

&lt;li&gt;&lt;a href='&lt;res:url uri='cai:SampleProvider:test1'/&gt;'&gt; 
SampleProvider:test1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href='&lt;res:url uri='cai:SampleProvider:test2'/&gt;'&gt; 
SampleProvider:test2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
</pre>

<a name="lookup"></a><h3>Lookup of service URLs for URIs</h3>
Content handlers that feature custom servlets to expose their functionality via HTTP need to extend the resolver infrastructure to expose a mapping between URI and their custom URLs. It is possible to specify arbitrary mappings, including mappings to servlets in different web applications, different servers, etc

Handlers provide a COR extension that is registered with the handler specific URI scheme. This extension must implement the com.ibm.portal.resolver.LookupService interface. It maps a URI and a parameter map to a com.ibm.portal.resolver.Lookup interface that in turn generates a JAXP source object. The contract for the XML stream represented by the source object is that it is a valid ATOM entry document for the URI/parameter combination. In case the lookup servlet is requested to only lookup one single URI, the XML source provided by the respective handler will potentially be streamed directly through to the client. In case the lookup servlet needs to lookup more than one URI in a single request, it will aggregate the individual feeds of ATOM entries from multiple handlers into one single ATOM feed. 

<a name="tags"></a><h3>Tag API for the resolver infrastructure</h3>
The following tags can be used to generate URLs that result in a resolution step to a URI.
The namespace of the taglibrary is <code>http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/resolver</code>.

<table border="1">
<tr>
<td><em>Tag</em></td>
<td>resolvedURL</td>
<td></td>
</tr>

<tr>
<td>required</td>
<td>uri</td>
<td>URI of the piece of content to be addressed</td>
</tr>

<tr>
<td>optional</td>
<td>allowRelativeURL</td>
<td>If set to "true", the generation of relative URLs is explicitly allowed (though not enforced).
If set to "false", no relative URLs will be generated. If missing, the server default setting
for the generation of relative URLs will be used.</td>
</tr>

<tr>
<td>optional</td>
<td>keepNavigationalState</td>
<td>If set to "true" the URLs contain the current navigational state. If set to
"false" the URLs will be generated without navigational state. If missing the URLs
will contain navigational state if possible.</td>
</tr>

<tr>
<td>optional</td>
<td>mode</td>
<td>Specification of the way the system should interact with the URI. Default modes are <code>VIEW</code>,
<code>DOWNLOAD</code> and <code>LOOKUP</code>.</td>
</tr>

<tr>
<td>optional</td>
<td>escapeXml</td>
<td>If set to "true" the URLs will be markup escaped. Per default this value is set to "true".</td>
</tr>

<tr>
<td>optional</td>
<td>protected</td>
<td>If set to "true" the URLs will point to the protection version of the target servlet, if 
set to "false" they point to the unprotected version, if missing the URLs point to the same
flavor of the target servlet as the current request.</td>
</tr>

<tr>
<td>optional</td>
<td>secure</td>
<td>If set to "true" the URLs will use HTTPS as the protocol, if set to "false" they use HTTP, if missing the URLs point to the same
flavor of the target servlet as the current request.</td>
</tr>

<tr>
<td><em>Tag</em></td>
<td>urlParam</td>
<td>To be used in the body of the resolvedURL tag.</td>
</tr>

<tr>
<td>required</td>
<td>name</td>
<td>Name of the parameter to attach to the URL. If there was already a parameter with
the given name, the values will be merged.</td>
</tr>

<tr>
<td>required</td>
<td>value</td>
<td>Value of the parameter to attach to the URL. If the value is of type Object[] the
array entries will be converted to String and appended to the list of parameters for the
given key. In all other cases the value is converted to a String and appended.</td>
</tr>

</table>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/ibm/portal/propertybroker/service/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/ibm/portal/resolver/accessors/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/ibm/portal/resolver/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
